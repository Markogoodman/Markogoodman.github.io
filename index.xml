<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Marko</title>
    <link>https://markogoodman.github.io/</link>
    <description>Recent content on Marko</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>marko958m@gmail.com (Marko Peng)</managingEditor>
    <webMaster>marko958m@gmail.com (Marko Peng)</webMaster>
    <copyright>©{2020}, All Rights Reserved</copyright>
    <lastBuildDate>Fri, 19 Dec 2025 16:37:39 -0500</lastBuildDate>
    
        <atom:link href="https://markogoodman.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      

      
      <item>
        <title>Attention and Transformer</title>
        <link>https://markogoodman.github.io/posts/attention-and-tranformer/</link>
        <pubDate>Fri, 19 Dec 2025 16:37:39 -0500</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 19 Dec 2025 16:37:39 -0500</atom:modified>
        <guid>https://markogoodman.github.io/posts/attention-and-tranformer/</guid>
        <description>Writting down some notes when tring to understand these 2 things.
Some prerequisites Optional:
Neural Networks Visualized Video
A blog post about LSTM
These 2 are the earlier version of AI. It describes what neural network is and how LSTM improves it.
Not directly related to Attention and Transformer.
Required:
Word embedding. But no need to go deep. Just need to know that a matrix is used to represent a word&amp;rsquo;s meaning in a vector space.</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
        
          
            
              <category>CS</category>
            
          
        
        
          
            
          
        
      </item>
      
      <item>
        <title>Attention and Transformer</title>
        <link>https://markogoodman.github.io/posts/attention-and-transformer/</link>
        <pubDate>Fri, 19 Dec 2025 16:37:39 -0500</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 19 Dec 2025 16:37:39 -0500</atom:modified>
        <guid>https://markogoodman.github.io/posts/attention-and-transformer/</guid>
        <description>Writting down some notes when tring to understand these 2 things.
Some prerequisites Optional:
Neural Networks Visualized Video
A blog post about LSTM
These 2 are the earlier version of AI. It describes what neural network is and how LSTM improves it.
Not directly related to Attention and Transformer.
Required:
Word embedding. But no need to go deep. Just need to know that a matrix is used to represent a word&amp;rsquo;s meaning in a vector space.</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
        
          
            
              <category>CS</category>
            
          
        
        
          
            
          
        
      </item>
      
      <item>
        <title>Transport Layer Note</title>
        <link>https://markogoodman.github.io/posts/tcp/</link>
        <pubDate>Wed, 24 Apr 2024 21:28:05 -0400</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Wed, 24 Apr 2024 21:28:05 -0400</atom:modified>
        <guid>https://markogoodman.github.io/posts/tcp/</guid>
        <description>Some notes References: https://github.com/forthright48/notes/blob/master/books/computer-networking.md https://blog.yfxie.com/comparison-of-network-gbn-sr-and-tcp/ 中文版在下面 &amp;mdash; English Version &amp;mdash; Transport Layer Two important protocols: UDP and TCP This article will mainly focus on how reliable transmission works. To be reliable Error checking, checksum Detect lost packets (timeout, etc.) Feedback from receiver to make sure they have received, which might lose as well. Retransmisison It&amp;rsquo;ll be slow if it waits for receiver&amp;rsquo;s feedback after sending</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>TCP</category>
            
          
            
              <category>Internet</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
          
        
      </item>
      
      <item>
        <title>Bloom Filter</title>
        <link>https://markogoodman.github.io/posts/bloom-filter/</link>
        <pubDate>Sat, 14 Oct 2023 21:42:23 -0400</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 14 Oct 2023 21:42:23 -0400</atom:modified>
        <guid>https://markogoodman.github.io/posts/bloom-filter/</guid>
        <description>Bloom filter Bloom filter 是一個概念很簡單又好用的東西，之前看過就想記錄一下 為何要用 Bloom filter 可以快速確認一個 key 是否存在一個資料集內，且不需花太多空間來儲存這些多餘</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
          
        
      </item>
      
      <item>
        <title>How to solve spark large amount of small files problem</title>
        <link>https://markogoodman.github.io/posts/spark-small-file-problem/</link>
        <pubDate>Sun, 02 Jul 2023 16:30:51 -0400</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sun, 02 Jul 2023 16:30:51 -0400</atom:modified>
        <guid>https://markogoodman.github.io/posts/spark-small-file-problem/</guid>
        <description>How to solve spark large amout of small files problem It&amp;rsquo;s a technical issue I solved when working. Problen Description In our data pipeline, an hourly spark job writes data to AWS S3. The data and directory structure looks like this: /job_name_start_time/event_timestamp_minute/data_1 /job_name_start_time/event_timestamp_minute/data_2 ... At time T the job will process all the events generated between T-1hour ~ T. For example, an event generated by job JobX at 2020-03-04 10:30AM</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Spark</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Parquet</title>
        <link>https://markogoodman.github.io/posts/parquet/</link>
        <pubDate>Sun, 26 Feb 2023 11:38:07 -0500</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sun, 26 Feb 2023 11:38:07 -0500</atom:modified>
        <guid>https://markogoodman.github.io/posts/parquet/</guid>
        <description>Parquet 最近在工作上要把一堆 spark app 讀的檔案從 json 換成 parquet 就小小研究一下這東西到底是什麼 parquet 其實就是一種資料儲存的檔案格式，且是 binary encoding，人眼看不</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>parquet</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>2 Phase Commit</title>
        <link>https://markogoodman.github.io/posts/2-phase-commit/</link>
        <pubDate>Fri, 30 Sep 2022 16:58:48 -0400</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 30 Sep 2022 16:58:48 -0400</atom:modified>
        <guid>https://markogoodman.github.io/posts/2-phase-commit/</guid>
        <description>看了 DDIA 第九章 記錄一下 2 phase commit 是用來做 multiple nodes tansaction 時使用的方法 single node transaction 通常都是由 log 與 commit 來達成 postgresql.org/docs/current/wal-intro.html 例如 postgres 的做法就是每個操作都會有一個 write-ahead-log (wal)，接著會把資</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>2 phase commit</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>DynamoDB Index</title>
        <link>https://markogoodman.github.io/posts/dynamodb-index/</link>
        <pubDate>Mon, 28 Mar 2022 22:24:17 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Mon, 28 Mar 2022 22:24:17 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/dynamodb-index/</guid>
        <description>DynamoDB index 這篇想講一下用 DynamoDB 遇到的狀況，字很多但內容應該很少，比較像流水帳 前陣子工作時需要將 DynamoDB 的全部資料(包括已經存在的和未來新來的)載入進 Redshift 並在途</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>DynamoDB</category>
            
          
            
              <category>index</category>
            
          
            
              <category>database</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>AWS，如何把原本使用 AWS console 建立的資源完整搬到 cdk 內</title>
        <link>https://markogoodman.github.io/posts/aws-migrate-from-existing-resource-to-cdk/</link>
        <pubDate>Fri, 31 Dec 2021 00:16:00 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 31 Dec 2021 00:16:00 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/aws-migrate-from-existing-resource-to-cdk/</guid>
        <description>如何把原本使用 AWS console 建立的資源完整搬到 cdk 內 目前公司使用 AWS 上是手動與 cdk 混著用，早期的東西都是用手動建立的，例如 Dynamodb table，裡面的 index 等等。 但後來</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
          
        
      </item>
      
      <item>
        <title>Redis Sorted Set</title>
        <link>https://markogoodman.github.io/posts/redis-sorted-set/</link>
        <pubDate>Thu, 09 Dec 2021 22:15:30 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Thu, 09 Dec 2021 22:15:30 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/redis-sorted-set/</guid>
        <description>Redis 裡面有一種 data type 叫做 sorted set 簡單來說就是一堆 key:value，但這些資料會依照 value (score) 來排序 讓使用者可以快速取得某個 key 的排名，或是一個排名範圍(或</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Redis</category>
            
          
            
              <category>Sorted set</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Http 4 Way Handshake</title>
        <link>https://markogoodman.github.io/posts/http-4-way-handshake/</link>
        <pubDate>Fri, 08 Oct 2021 00:20:29 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 08 Oct 2021 00:20:29 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/http-4-way-handshake/</guid>
        <description>4 way handshake 在 tcp 連線要結束時則是需要四次握手 Ａ -&amp;gt; Ｂ FIN Ｂ -&amp;gt; Ａ ACK Ｂ -&amp;gt; Ａ FIN Ａ -&amp;gt; Ｂ ACK 當 A 想要結束連線時就傳送 FIN 給 B，B 先確認 FIN 之前的資料都收到之後回傳 ACK 給</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>HTTP</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Protobuf and Json</title>
        <link>https://markogoodman.github.io/posts/protobuf-and-json/</link>
        <pubDate>Tue, 10 Aug 2021 02:47:53 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Tue, 10 Aug 2021 02:47:53 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/protobuf-and-json/</guid>
        <description>protobuf vs json 最近工作新專案要把原有的 http request 和 response 都從 json 改為 protobuf 預期是可以讓網路傳輸量還有 (de)serialize 加速～ 所以這邊想研究一下 protobuf 到底是做了什麼才比 json 快 json 基本上 json 就是</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>protobuf</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>How Channel Works</title>
        <link>https://markogoodman.github.io/posts/how-channel-works/</link>
        <pubDate>Wed, 09 Jun 2021 01:27:44 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Wed, 09 Jun 2021 01:27:44 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/how-channel-works/</guid>
        <description>How channel works Note of https://www.youtube.com/watch?v=KBZlN0izeiY&amp;amp;ab_channel=GopherAcademy by Kavya Joshi. Channel ！！！ goroutine-safe store data、FIFO pass data between goroutines block, unblock goroutine making channels https://golang.org/src/runtime/chan.go hchan struct contains buf -&amp;gt; circular queue (with send index &amp;amp; receive index) sendx recvx mutex sendq // list of sudo g recvq // list of sudo g &amp;hellip; ch := make(chan Task, 3) This comman</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Channel</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>怎麼安裝 homebrew 裡面的舊版 package</title>
        <link>https://markogoodman.github.io/posts/brew-install-older-pkg/</link>
        <pubDate>Fri, 28 May 2021 01:18:29 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 28 May 2021 01:18:29 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/brew-install-older-pkg/</guid>
        <description>怎麼裝舊版的 homegrew 套件 工作的時候要裝 protobuf 的 3.15.8 版，沒想到 homebrew 不給裝ＲＲＲ 用 brew info protobuf 查了一下現在最新版已經到 3.17.x 了，3.15.8 也沒列出來 估狗了一下發現這篇</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
          
        
      </item>
      
      <item>
        <title>Hyperloglog</title>
        <link>https://markogoodman.github.io/posts/hyperloglog/</link>
        <pubDate>Wed, 19 May 2021 00:58:01 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Wed, 19 May 2021 00:58:01 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/hyperloglog/</guid>
        <description>Hyperloglog 這也是在工作接觸到的東西，是用來做基數統計的一個方法 第一次看到真的覺得這是什麼巫術0.0 目的是要做一個按讚的系統 就是玩家可以重複對某個影片</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>redis</category>
            
          
            
              <category>hyperloglog</category>
            
          
            
              <category>cardinality</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Redis Transaction 使用</title>
        <link>https://markogoodman.github.io/posts/redis-transaction/</link>
        <pubDate>Sun, 09 May 2021 00:06:32 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sun, 09 May 2021 00:06:32 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/redis-transaction/</guid>
        <description>Redis transaction 工作時有需要做一個 Set if key exists 發現 redis 只提供一個 SETNX，Set if key doesn&amp;rsquo;t exist 順便來研究一下 redis 的 transaction MULTI https://redis.io/topics/transactions 在 redis 裡面做 transaction 基本上就是使用 MULTI MULTI SET key0 value0 SET key1 value1 EXEC</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Redis</category>
            
          
            
              <category>Transaction</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Docker</title>
        <link>https://markogoodman.github.io/posts/docker/</link>
        <pubDate>Sun, 25 Apr 2021 16:12:26 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sun, 25 Apr 2021 16:12:26 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/docker/</guid>
        <description>Docker https://www.youtube.com/watch?v=3c-iBn73dDE 前幾天看了一個簡單介紹 docker 的影片還滿完整的，紀錄一下大概講了什麼，沒有太深入的東西不過應該滿夠用的 他裡面有做了一個簡單的範例，之後要用應該</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>docker</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>What Is Websocket</title>
        <link>https://markogoodman.github.io/posts/what-is-websocket/</link>
        <pubDate>Mon, 12 Apr 2021 23:44:15 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Mon, 12 Apr 2021 23:44:15 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/what-is-websocket/</guid>
        <description>Websocket https://www.cnblogs.com/nuccch/p/10947256.html#websocket%E5%8D%8F%E8%AE%AE%E6%98%AF%E4%BB%80%E4%B9%88 是一個應用層的 protocol (跟 http 同層) 最重要的功用大概就是雙向傳輸，建立連線後就把連線開著，client 和 server 之間都可以互相傳訊息，且 overhead 比 http 少 http 傳送</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>http</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>What Is Http</title>
        <link>https://markogoodman.github.io/posts/what-is-http/</link>
        <pubDate>Mon, 12 Apr 2021 23:40:36 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Mon, 12 Apr 2021 23:40:36 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/what-is-http/</guid>
        <description>HTTP 們 HTTP https://notfalse.net/39/http-message-format HyperText Transfer Protocol 一種應用層的通訊協定 簡單來說就是應用程式之間的一種溝通規範，規定好大家資料格式長什麼樣子，互相該如何來回訊息。如果大家都依照這</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>http</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Concurrency in Go IV 第六章 Goroutines and the Go runtime</title>
        <link>https://markogoodman.github.io/posts/concurrency-in-go-iv/</link>
        <pubDate>Sat, 13 Mar 2021 20:53:52 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 13 Mar 2021 20:53:52 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/concurrency-in-go-iv/</guid>
        <description>這章節是概略介紹一下 Go 的 scheduler 如何運作的～ 有些事之前有看過 不過 tasks 和 continuation 真的是第一次聽到，滿有趣的概念 Work Stealing Fair scheduling，直接把一堆任務平均</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>concurrency</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Concurrency in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Concurrency in Go III  第五章 Concurrency at Scale</title>
        <link>https://markogoodman.github.io/posts/concurrency-in-go-iii/</link>
        <pubDate>Sat, 13 Mar 2021 20:52:13 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 13 Mar 2021 20:52:13 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/concurrency-in-go-iii/</guid>
        <description>筆記都沒啥整理Ｒ Error Propagation // 好像跟 concurrency 比較無關(? 寫 concurrent code 的時候，debug 會比平常難很多，如果互相傳遞資訊時都附上 error 會比較好 Error需要包含一些東</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>concurrency</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Concurrency in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Concurrency in Go - II 第四章</title>
        <link>https://markogoodman.github.io/posts/concurrency-in-go-ii/</link>
        <pubDate>Sun, 28 Feb 2021 22:32:38 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sun, 28 Feb 2021 22:32:38 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/concurrency-in-go-ii/</guid>
        <description>Concurrency in go. 第四章 Concurrency Patterns in Go 這章節就是講一些常見的 Go concurrency pattern，有哪些方便使用以及如何安全的使用這些 pattern confinement 要做到 concurrent safe 除了之前說的 channel 與 primitives 還有些方法</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>concurrency</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Concurrency in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Concurrency in Go - I 前三章</title>
        <link>https://markogoodman.github.io/posts/concurrency-in-go-i/</link>
        <pubDate>Sat, 27 Feb 2021 23:21:42 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 27 Feb 2021 23:21:42 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/concurrency-in-go-i/</guid>
        <description>這三章節內容其實滿少的，讀過之後隨便記一記 ch1 Why Is Concurrency Hard? Race condition 應該要依序執行的不同指定們，沒有依照正確的順序造成結果錯誤 例如下面這段程式就有可能出</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>concurrency</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Concurrency in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Gqlgen</title>
        <link>https://markogoodman.github.io/posts/gqlgen/</link>
        <pubDate>Sat, 23 Jan 2021 01:04:19 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 23 Jan 2021 01:04:19 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/gqlgen/</guid>
        <description>一直都聽說 Graphql 很潮(? 工作上其實也有遇到類似的問題，一個玩家的資料有一堆欄位，常常因為各種需求加了一堆參數或 API 來拿裡面的不同欄位，graphq</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>gqlgen</category>
            
          
            
              <category>graphql</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>垃圾回收！</title>
        <link>https://markogoodman.github.io/posts/gc/</link>
        <pubDate>Wed, 16 Dec 2020 22:35:13 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Wed, 16 Dec 2020 22:35:13 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/gc/</guid>
        <description>tags: Golang 垃圾回收～～～ 追蹤heap裡面的mem 刪除沒在用的 保留有在用的 主要有分兩大類 一. Reference counting 每個 obj 記住自己有被多少人連結到，歸零的時候順便回收 例</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Garbage collection</category>
            
          
            
              <category>垃圾回收</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Csrf</title>
        <link>https://markogoodman.github.io/posts/csrf/</link>
        <pubDate>Sat, 17 Oct 2020 15:05:29 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 17 Oct 2020 15:05:29 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/csrf/</guid>
        <description>筆記一下研究 csrf 查到的資料，有些小地方網路上的資料都滿模糊的真的查有夠久 XD CSRF (Cross-site request forgery) 基本原理 基本原理就是使用者在某個 A 網站認證(登入帳號之類的)</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>csrf</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Scheduling in Go Part III</title>
        <link>https://markogoodman.github.io/posts/scheduling-in-go-part-iii/</link>
        <pubDate>Sat, 19 Sep 2020 21:41:43 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 19 Sep 2020 21:41:43 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/scheduling-in-go-part-iii/</guid>
        <description>Part III: Examples Goroutine 的運作原理其實在前面兩篇就有很好的解釋拉 這個部分主要是給一些實際的例子，會介紹一下平行與並行適合的是哪些情況，Goroutine 到底</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>scheduler</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Scheduling in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Scheduling in Go Part II</title>
        <link>https://markogoodman.github.io/posts/scheduling-in-go-part-ii/</link>
        <pubDate>Sat, 12 Sep 2020 00:54:03 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 12 Sep 2020 00:54:03 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/scheduling-in-go-part-ii/</guid>
        <description>https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html 以下截圖都是從這個網站來的 Part II: Go Scheduler 這部分要開始介紹 Go 的 Scheduler 是怎麼運作的，以及它的優勢在哪裡 在 Go 裡面執行 runtime.NumCPU() 可以知道目前的電腦有幾個 virtual core (看有幾</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>scheduler</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Scheduling in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Go 的 MAP 要不要用指標</title>
        <link>https://markogoodman.github.io/posts/go-map/</link>
        <pubDate>Fri, 17 Jul 2020 23:19:11 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Fri, 17 Jul 2020 23:19:11 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/go-map/</guid>
        <description>一開始用 Go 的 Map 時常常搞不清楚到底要不要傳指標，好像大部分的時候都不用，但用到 unmarshal 之類的 function 就又要傳指標進去了。 這篇就來研究一下 Go 的 Map 到底是什麼生</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>map</category>
            
          
            
              <category>pointer</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>Goroutine 為啥那麼快 (Scheduling in Go) Part I</title>
        <link>https://markogoodman.github.io/posts/scheduling-in-go-part-i/</link>
        <pubDate>Sat, 11 Jul 2020 00:16:33 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 11 Jul 2020 00:16:33 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/scheduling-in-go-part-i/</guid>
        <description>關於這系列文 之前看了 Ardan labs 寫的下面這個系列文還滿不錯的 https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html 主要是在講 Goroutine 和一般我們看到的 thread 比起來到底厲害在哪裡，也舉了一些範例讓讀者知道 Goroutine 用在哪裡</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>Go</category>
            
          
            
              <category>Goroutine</category>
            
          
            
              <category>scheduler</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
          
            
              <category>Scheduling in Go</category>
            
          
        
      </item>
      
      <item>
        <title>Mongodb Partial and Sparse Index</title>
        <link>https://markogoodman.github.io/posts/mongodb-partial-sparse-index/</link>
        <pubDate>Sun, 14 Jun 2020 02:19:55 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sun, 14 Jun 2020 02:19:55 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/mongodb-partial-sparse-index/</guid>
        <description>前幾天幫原本已經有資料的 collection 新建 unique index 的時候讓 Server 啟動爆掉了記錄一下 1 2 3 db.coll.insert({&amp;#34;a&amp;#34;:1}) db.coll.insert({&amp;#34;a&amp;#34;:2}) db.coll.createIndex({&amp;#34;b&amp;#34;:1}, {unique: true}) // duplicate key error 在一個之前資料都沒有的 field 上建 unique index，結果噴出了下</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
          
            
              <category>mongodb</category>
            
          
            
              <category>index</category>
            
          
            
              <category>database</category>
            
          
        
        
          
            
              <category>程式</category>
            
          
        
        
      </item>
      
      <item>
        <title>My First Post</title>
        <link>https://markogoodman.github.io/posts/my-first-post/</link>
        <pubDate>Sat, 13 Jun 2020 22:46:37 +0800</pubDate>
        <author>marko958m@gmail.com (Marko Peng)</author>
        <atom:modified>Sat, 13 Jun 2020 22:46:37 +0800</atom:modified>
        <guid>https://markogoodman.github.io/posts/my-first-post/</guid>
        <description>汪</description>
        
        <dc:creator>Marko Peng</dc:creator>
        
        
        
        
        
        
      </item>
      

    
  </channel>
</rss>